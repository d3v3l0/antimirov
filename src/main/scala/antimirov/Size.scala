package antimirov

/**
 * Extended integer representation of sizes.
 *
 * This class is used to represent the lengths of matched strings.
 * Unbounded values are generated by things like the Kleene star
 * operator.
 *
 * Size supports addition and multiplication. Additionally, Size has a
 * total ordering (unbounded values are considered), so comparisons
 * are also supported.
 *
 * Sizes are required to be non-negative, i.e. 0 <= size < ∞.
 */
sealed abstract class Size { lhs =>

  import Size.{Finite, Unbounded}

  def +(rhs: Size): Size =
    (lhs, rhs) match {
      case (Finite(x), Finite(y)) => Finite(x + y)
      case _ => Unbounded
    }

  def *(rhs: Size): Size =
    (lhs, rhs) match {
      case (Size.Zero, _) | (_, Size.Zero) => Size.Zero
      case (Finite(x), Finite(y)) => Finite(x * y)
      case _ => Unbounded
    }

  def pow(k: Int): Size = {
    def loop(i: Int, acc: Size, mult: Size): Size =
      if (i <= 0) Size.One
      else if (i == 1) mult
      else loop(i / 2, if (i % 2 == 1) acc * mult else acc, mult * mult)
    loop(k, Size.One, this)
  }

  override def toString: String =
    this match {
      case Unbounded => "∞"
      case Finite(n) => n.toString
    }

  def <(rhs: Size): Boolean = compare(rhs) < 0
  def <=(rhs: Size): Boolean = compare(rhs) <= 0
  def >(rhs: Size): Boolean = compare(rhs) > 0
  def >=(rhs: Size): Boolean = compare(rhs) >= 0

  def min(rhs: Size): Size =
    if (lhs <= rhs) lhs else rhs

  def max(rhs: Size): Size =
    if (lhs >= rhs) lhs else rhs

  def compare(rhs: Size): Int =
    (lhs, rhs) match {
      case (Finite(x), Finite(y)) => Integer.compare(x, y)
      case (Finite(_), Unbounded) => -1
      case (Unbounded, Finite(_)) => 1
      case (Unbounded, Unbounded) => 0
    }
}

object Size {

  val Zero = Size(0)
  val One = Size(1)

  def apply(n: Int): Size = {
    require(n >= 0)
    Finite(n)
  }

  case class Finite private[antimirov] (n: Int) extends Size
  case object Unbounded extends Size
}
